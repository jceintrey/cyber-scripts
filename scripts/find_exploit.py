#!/usr/bin/env python3
# find_exploits.py
# Usage: python3 find_exploits.py installed_wmic.csv /usr/share/exploitdb/exploits.csv results.json
# First collect installed softwares via: wmic product get name,version,vendor /format:csv > C:\Temp\installed_wmic.csv

import csv
import sys
import os
import json
import re

def normalize(s):
    if not s:
        return ""
    s = s.lower()
    s = re.sub(r'[^a-z0-9\.\- ]+', ' ', s)
    s = re.sub(r'\s+', ' ', s).strip()
    return s

if len(sys.argv) < 3:
    print("Usage: python3 find_exploits.py installed.csv /path/to/exploits.csv [out.json]")
    sys.exit(1)

installed_csv = sys.argv[1]
exploit_csv = sys.argv[2]
out_file = sys.argv[3] if len(sys.argv) > 3 else "exploit_matches.json"

if not os.path.exists(installed_csv):
    print("installed csv not found:", installed_csv); sys.exit(1)
if not os.path.exists(exploit_csv):
    print("exploit csv not found:", exploit_csv); sys.exit(1)

# Load exploitdb CSV into memory (id, date, exploit_title, author, platform, type, path, etc)
exploits = []
with open(exploit_csv, newline='', errors='ignore') as f:
    reader = csv.reader(f)
    for row in reader:
        # exploits.csv typical columns: id, file, description, author, date, platform, type
        if len(row) < 3:
            continue
        exploits.append({
            'id': row[0],
            'file': row[1],
            'description': row[2],
            'author': row[3] if len(row) > 3 else '',
            'date': row[4] if len(row) > 4 else '',
            'platform': row[5] if len(row) > 5 else '',
            'type': row[6] if len(row) > 6 else '',
        })

matches = []

with open(installed_csv, newline='', errors='ignore') as f:
    reader = csv.reader(f)
    header = next(reader, None)
    for row in reader:
        # handle wmic CSV Node,Name,Version,Vendor
        if len(row) >= 4:
            name, version, vendor = row[1], row[2], row[3]
        elif len(row) >= 3:
            name, version, vendor = row[0], row[1], row[2]
        else:
            continue

        nname = normalize(name)
        nver = normalize(version)
        if not nname:
            continue

        # try to find matches by name substring
        for ex in exploits:
            desc = normalize(ex['description'])
            # match if name is in description or description contains vendor+name
            if nname in desc:
                # optional: check version number tokens in description
                ver_ok = False
                if nver and nver != "":
                    # quick check for version token
                    if nver in desc:
                        ver_ok = True
                matches.append({
                    'product': name,
                    'version': version,
                    'vendor': vendor,
                    'exploit_id': ex['id'],
                    'exploit_file': ex['file'],
                    'exploit_desc': ex['description'],
                    'match_snippet': ex['description'][:200]
                })

# deduplicate by exploit id
unique = {}
for m in matches:
    unique_key = m['exploit_id'] + '|' + m['product']
    if unique_key not in unique:
        unique[unique_key] = m

result_list = list(unique.values())
with open(out_file, 'w', encoding='utf-8') as f:
    json.dump(result_list, f, indent=2, ensure_ascii=False)

print(f"Found {len(result_list)} potential matches. See {out_file}")

